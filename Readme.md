# Инструкция для работы с Git и удалёнными репозиторими

## Что такое Git?

***Git*** - это одна из реализаций распределённых систем контроля версий, имеющая как и `локальные`, так и `удалённые` репозитории. Является самой популярной реализацией систем контроля версий в мире.

Для создание репозитория необходимо выполнить команду **git init** в папке с репозиторием и у Вас создаться репозиторий (появится скрытая папка .git)

## Создание коммитов

### Git add

 Для добавления измений в коммит используется команда **git add**. Чтобы использовать команду *git add* напишите ***git add <имя файла>***

## Просмотр состояния репозитория

 Для того, чтобы посмотреть состояние репозитория используется команда **git status**, для этого необходимо в папке с репозиторием написать *git status*, и Вы увидите были ли измения в файлах, или их не было.

## Сохранение коммитов

Для того, чтобы создать коммит(сохранение) необходимо выполнить команду **git commit -m**. При написании комманды `git commet` - Необходимо добавить комментарий к изменению. Выполняется снимок текущего состояния изменений, добавленных в раздел проиндексированных файлов.

 Такие подтвержденные снимки состояния можно рассматривать как "безопасные" версии проекта - Git не будет их менять пока вы не попросите об этом. **Перед выполнением команды *git commit* необходимо использовать комманду *git add*, чтобы проидексировать изменения которые будут сохранены в коммите**.

## Что такое удаленный репозиторий?

**Удаленный("внешний") репозиторий** - это версии вашего проекта, сохраненные на удаленном сервере. Доступ к репозиторию на таком сервере может осуществляться по интернету или по локальной сети.

`Удаленный репозиторий` – полноценный репозиторий, ничем не отличающийся от локального. У удаленного репозитория есть собственные ветки, собственный указатель *HEAD*, своя история коммитов и так далее.

Если мы подключим удаленный репозиторий к своему локальному, то у нас появятся копии всех ссылочных объектов удаленного репозитория. То есть, например, у удаленного репозитория есть ветка main, а у нас будет копия этой ветки – **origin/main**. Все такие ссылочные объекты (указатели, ветки и теги) удаленного репозитория хранятся почти там же, где и у локального – в директории `.git/refs/remotes/<имя_удаленного_репозитория>`.

### Настройка подключения удаленного репозитория. Группа команд **git remote**

Необходимость подключить удаленный репозиторий к уже существующему локальному возникает в ситуациях, *когда вы решаете выгрузить уже написанный код на удаленный сервер*. Это нужно, чтобы другие разработчики смогли получить к нему доступ или чтобы вы сами могли заниматься разработкой с нескольких компьютеров (например, домашнего и рабочего).

Для управления подключением удаленных репозиториев в Git предусмотрена целая группа команд – `git remote`. Мы рассмотрим самые частоиспользуемые команды из этой группы.

### Добавление удаленного репозитория к существующему локальному

Давайте разберемся, как добавить удаленный репозиторий к вашему локальному репу. Для этого в Git есть команда **git remote add**.

 `git remote add "название удаленного репозитория" "ссылка на удаленный репозиторий" - Подключает удаленный репозиторий к вашему под переданным именем.`

*Имя удаленного репозитория* в команде *git remote add* вы можете придумать сами. Впоследствии, при работе с этим удаленным репозиторием, вы будете обращаться к нему по придуманному имени. Принято называть удаленный репозиторий origin, но строго говоря, никаких ограничений здесь нет.

Со ссылкой на удаленный репозиторий тоже все просто. Мы работаем с GitHub, поэтому эту ссылку можно взять, нажав на большую зеленую кнопку **Code** на странице репозитория на GitHub.

## HTTPS, SSH и CLI

Начнем с **CLI** - эта ссылка используется в клиенте GitHub, который нужен для упрощения работы с Git. Этот клиент можно поставить отдельно, но его возможности значительно ограничены по сравнению с консольным вариантом Git.

Итак, с последней ссылкой все понятно: ее нужно использовать в специальной программе для компьютера с графическим *UI* от создателей GitHub. Но в чем разница между первыми двумя?

Дело в том, что существует два основных протокола подключения к **git-серверу**: **HTTPS** и **SSH**.

**SSH** считается более надежным, но он немного сложнее в настройке. Давайте разберемся, как настроить подключение для каждого из них.

### Настройка подключения по **HTTPS**

Раньше можно было подключаться по *HTTPS*, используя имя пользователя и пароль от аккаунта GitHub. Но потом эту возможность отключили в целях безопасности. Сейчас вместо пароля нужно использовать персональный токен. Давайте разберемся, как создать такой токен.

Итак, чтобы создать токен персонального доступа, следуйте инструкции:

1. Подтвердите свой **email-адрес**, который вы использовали при регистрации аккаунта GitHub (если он не подтвержден)
2. Кликните на свою аватарку в правом верхнем углу, в открывшемся окне выберите **Settings** (Настройки):
3. Перед вами откроются настройки. В меню слева выберите **Developer settings** (Настройки разработчика)
4. Перед вами откроются Настройки разработчика. В меню слева выберите **Personal access tokens** (токены персонального доступа).
5. Нажмите **Generate new token** (сгенерировать новый токен)
6. Придумайте имя для своего токена. Имя должно описывать, зачем токен был создан.
7. Дайте токену разрешения. Пользователь токена сможет выполнять с удаленным репозиторием только то, что вы указали в этих разрешениях. Чтобы дать токену доступ к управлению удаленным репозиторием из командной строки, выберите **repo**.
8. Нажмите **Generate token** (сгенерировать токен).
9. Скопируйте токен. В целях безопасности, как только вы покинете страницу создания токена, *вы больше не сможете просмотреть этот токен.*

### Настройка подключения по SSH

Чтобы настроить подключение по **SSH**, вам нужно на своем компьютере сгенерировать два **SSH-ключа**: *публичный (public) и секретный (private*).

Как работает **SSH протокол** и зачем ему ключи? Если коротко, то публичный ключ передается на удаленный сервер, а секретный все время остается с вами. Удаленный сервер использует публичный ключ, чтобы удостовериться, что у вас действительно есть секретный ключ. Как только сервер убеждается в наличии у вас секретного ключа, он понимает, что вы – это вы, ведь секретный ключ нельзя подделать.

После создания пары ключей, надо добавить секретный ключ в **SSH-агента**.

**SSH-агент** – это специальная программа, которая сохраняет пароль от файла с секретным ключом и помогает удаленному серверу удостовериться, что вы действительно владеете секретным ключом. Благодаря **SSH-агенту**, вам не потребуется при каждом подключении к удаленному серверу вводить пароль от файла с приватным ключом.

После останется только загрузить наш публичный ключ на GitHub и готово. Давайте рассмотрим этот процесс подробнее:

1. Откройте **Git Bash** (или терминал, если вы работаете на *Linux/MacOS*)
2. Выполните в нем команду **ssh-keygen -t rsa 4096 -C "<ваша-почта>@example.com"**
 Вам предложат ввести путь к директории, в которой будет сохранен ключ, а также будет выведена директория для сохранения по умолчанию. Нажмите *Enter*, чтобы выбрать директорию по умолчанию, либо введите любую другую директорию и тоже нажмите *Enter*.
 Затем вам предложат ввести пароль для файла с секретным ключом. Нажмите *Enter*, чтобы оставить файл без пароля, либо введите пароль и нажмите *Enter*.
3. Теперь нужно добавить ключ в **SSH-агента**. Запустим агента командой `eval ssh-agent -s`
4. Теперь выполните команду `ssh-add <путь до приватного ключа>`. Если вы оставили путь по умолчанию, ваша команда будет выглядеть так: **ssh-add ~/.ssh/id_ed25519**
5. Отлично, последний этап: добавляем публичный ключ на **GitHub**. Для этого откройте файл с публичным ключом (он должен иметь расширение .pub). Если вы оставили путь по умолчанию, то ваш ключ будет располагаться по адресу `~/.ssh/id_ed25519.pub.`
6. Скопируйте содержимое файла.
7. Перейдите в настройки GitHub
8. Откройте раздел `SSH and GPG keys (ssh и gpg ключи)`
9. Нажмите `New SSH key` (новый ssh-ключ)
10. В поле **Title** (заголовок) введите содержательное название ключа, например **ключ для ноутбука** или **ключ рабочего компьютера**
11. Скопированный ключ вставьте в раздел **Key** (ключ)
12. Нажмите **Add SSH key** (добавить ssh-ключ)
13. Возможно потребуется ввести пароль для подтверждения действия.

Теперь SSH-ключ добавлен. Вам больше не нужно вводить имя пользователя и пароль при каждой загрузке или скачивании изменений из удаленного репозитория

### Отключение удаленного репозитория от локального

Иногда возникает необходимость **забыть** удаленный репозиторий. Для этого существует команда `git remote remove.`

### Изменение имени удаленного репозитория. Просмотр всех удаленных репозиториев

Иногда возникает необходимость переименовать удаленный репозиторий. Для этого существует команда `git remote rename "старое имя удаленного репозитория" "новое имя удаленного репозитория"`

Еще более частая задача – просмотреть список всех подключенных удаленных репозиториев и получить информацию о каждом из них. Для этого существует команда `git remote show`

`git clone "ссылка на удаленный репозиторий" - клонирование удаленного репозитория`

Заметьте, что клонирование по **https** возможно вообще всегда, а по **ssh** – нет. Чтобы клонировать репозитории по **ssh**, нужно, чтобы владелец удаленного репозитория на *GitHub* добавил к себе публичный **ssh-ключ** из пары, в то время, как секретный **ssh-ключ** от той же пары хранится у вас на компьютере, с которого вы выполняете ***git clone***. Таким образом, если вы настроили **ssh** в своем аккаунте, то вы сможете беспрепятственно клонировать свои репозитории и по **https**, и по **ssh**. Но если вы пытаетесь клонировать чужой репозиторий по **ssh**, то скорее всего получите ошибку доступа.

`Окончательный выбор протокола для клонирования, конечно, остается за читателем. Работать по https проще и быстрее, зато он считается менее защищенным, чем ssh, который в свою очередь труднее в настройке.`

### Получение изменений из удаленного репозитория

`git fetch "ключи" "имя удаленного репозитория"` - получить изменения из удаленного репозитория

Важным замечанием здесь станет то, что команда не обновляет рабочую копию в соответствии с удаленным репозиторием. Она обновляет только ссылочные объекты (указатели, ветки и теги) и скачивает все необходимые файлы в директорию **.git/objects.**

`git merge "ветка 1"/"ветка 2" - обьединение двух веток в одну.`

Кстати, в выводе команды **git merge** можно заметить, что слияние прошло в *fast-forward* режиме. Именно поэтому не было создано merge-коммита. На самом деле, слияние удаленной ветки очень часто можно выполнить в *fast-forward* режиме, но иногда все-таки приходится разрешать конфликты и создавать *merge-коммиты.*

Команда **git fetch** используется для синхронизации локальных ссылочных объектов с этими же объектами в удаленном репозитории. Рабочую копию она не меняет.
Чтобы синхронизировать локальную рабочую копию с удаленным репозиторием, нужно слить удаленные ветки в локальные. Сделать это можно уже знакомой командой **git merge.**

Связкой **git fetch && git merge** мы получили изменения из удаленного репозитория и обновили свою рабочую копию. Часто вместо этого хочется получать изменения и сразу обновлять рабочую копию так, чтобы она соответствовала удаленному репозиторию. И для этого в *Git* существует отдельная команда. Называется она **git pull**.

`git pull "ключи" "имя удаленного репозитория"` Получает изменения из переданного удаленного репозитория и обновляет рабочую копию в соответствии с удаленным репозиторием. По умолчанию слияние удаленной ветки с локальной происходит именно в fast-forward режиме, так что включать его специально не требуется.
Простым языком `git pull` используется для синхронизации локальной рабочей копии и всех ссылочных объектов с удаленным репозиторием.

**Ключи:**

* --ff
* --no-ff
* --ff-only

Эти ключи определяют стратегию слияния. **--ff** – включить fast-forward, если это возможно, **--no-ff** – отключить fast-forward, а **--ff-only** – остановить pull, если его невозможно сделать в fast-forward.

Команда **git pull** это просто сокращение последовательного применения **git fetch и git merge**. Но используется **git pull** намного чаще.

### Отправка изменений в удаленный репозиторий

`git push "ключи" "имя удаленного репозитория" "имя ветки"`

* Загружает изменения в удаленный репозиторий. Если слияние изменений в удаленном репозитории нельзя сделать в режиме fast-forward, и при этом не был передан ключ force, выполнение закончится с ошибкой.

**Ключи:**

* --all Пушит все имеющиеся ветки

* -f, --force
Перезаписывает удаленную ветку, вне зависимости от ее содержимого. Старайтесь не использовать этот флаг без крайней необходимости.

* --force-with-lease
Удаляет все коммиты, которых нет в локальном репозитории. Если коммит, который команда соберется удалять был создан другим пользователем, то выполнение закончится с ошибкой.

## **GitHub**

 `GitHub` – это, наверное, самый популярный сервис бесплатного хостинга удаленных репозиториев с множеством дополнительных функций. Среди них есть, например, создание **issue** – запросов, в которых можно сообщить разработчикам об ошибках, создание репозиториев-форков и пулл-реквестов. Кроме того, на *GitHub* можно подписаться на обновления какого-то конкретного пользователя или включить отслеживание репозитория вашего любимого проекта. Все это превращает *GitHub* в настоящую социальную сеть для разработчиков по всему миру. Давайте приступим к изучению основ работы с этим сервисом.

*Для дальнейшей работы требуется регистрация.*

### Создание репозитория на **GitHub**

Чтобы создать свой репозиторий, нажмите на зеленую кнопку **New**
Перед вами откроется страница создания репозитория. Давайте разберем, что за поля нам предлагают заполнить.

1. **Repository name** – имя репозитория. Здесь все просто, вам нужно придумать имя, которое будет отображаться на странице вашего репозитория. Здесь нет никаких ограничений, но старайтесь давать как можно более содержательные имена своим репозиториям.
2. **Description** – описание. Его заполнять необязательно. Но другим пользователям, которые попали на страницу вашего репозитория, будет проще понять, что перед ними, если вы заполните графу описания.
3. Затем вы можете выбрать, будет ли репозиторий **открытым**, то есть доступным абсолютно всем пользователям GitHub, или **закрытым**, то есть доступным только вам и людям, которым вы предоставите доступ.
4. Последние три поля предлагают нам добавить, соответственно, README-файл, .gitignore файл и выбрать лицензию для нашего проекта.

*Завершим процесс создания репозитория, нажав кнопку* ***Create repository.***

### Cтраница репозитория на **GitHub**

**Вкладки:**

1. Вкладка **Code**. Сейчас открыта именно она. В ней содержится рабочая копия нашего репозитория (по центру), описание (справа), вывод файла *README* (под рабочей копией), история коммитов, а также кнопки для клонирования репозитория и просмотра файлов.
2. Вкладка **Issues**. В этой вкладке будут отображаться все запросы, сделанные другими пользователями. Как правило, пользователи используют запрос, чтобы сообщить о найденном баге, либо чтобы задать какой-то вопрос о вашем приложении.
3. Вкладка **Pull-requests**. На этой вкладке будут отображаться все пулл-реквесты, сделанные другими пользователями. О том, что такое пулл-реквесты, мы поговорим ниже.
4. Вкладки **Actions** и **Project** относятся скорее к системе **CI/CDI**, которую предоставляет *GitHub*, в этом курсе мы не будем затрагивать их.
5. Вкладка **Wiki** открывает вам доступ к созданию и размещению документации о собственном проекте.
6. На вкладке **Security** содержатся различные настройки безопасности вашего проекта. Там же можно включить инспекцию вашего кода, чтобы узнать, если вы случайно загрузите какой-нибудь секретный токен на *GitHub*.
7. Вкладка **Insight** содержит различную информацию и статистические данные об активности репозитория. Там вы сможете посмотреть на зависимость количества коммитов в репозитории от времени или на процент коммитов, сделанных вами.
8. Последняя вкладка – **Settings**. В ней находятся различные настройки вашего репозитория. Там вы можете поменять видимость репозитория, сделав его частным, или вовсе удалить репозиторий.

### Создание форка репозитория на **GitHub**

`Форк` (от англ. **fork** – вилка) – точная копия репозитория, но в вашем аккаунте. Форки нужны, чтобы вносить свои изменения в проект, к репозиторию которого у вас нет прямого доступа.

`Пулл-реквест` (от англ. **pull-request** – запрос **pull**) – функция GitHub, позволяющая попросить владельца репозитория, от которого мы сделали форк, загрузить наши изменения обратно в свой репозиторий.

Если коротко, форки и *пулл-реквесты* нужны, чтобы любой пользователь мог внести свой вклад в любой открытый проект, репозиторий которого есть на *GitHub*. Кроме того, перед тем как влить ваши изменения в основной репозиторий, ответственные обязательно проверят ваш код на наличие ошибок и уязвимостей. Таким образом, даже если ваши изменения не примут, вы получите первоклассный **code-review** с указанием всех неточностей.

Давайте рассмотрим **пайплайн контрибуции** (англ. **contribution** – внесение вклада) на примере реального репозитория.

**Последовательность дейсвтвий:**

1. Для начала зайдем на страницу репозитория проекта. Нажимаем на кнопку **Fork**. После этого *Git* создаст точную копию этого репозитория в вашем аккаунте.
2. Клонируем репозиторий к себе на компьютер командой **git clone**. Создадим файл **README.md** с описанием проекта, чтобы другим пользователям было понятно, в чем отличие этой реализации от остальных.
3. Сделаем коммит и выполним **git push**, чтобы загрузить наши изменения в удаленный репозиторий.
4. Теперь *GitHub* подсказывает нам, что наша ветка опережает ветку исходного репозитория на один коммит и предлагает сделать пулл-реквест.
5. Нажимаем на кнопку **Compare** на подсказке *GitHub*, либо переходим на вкладку **Pull Requests** и нажимаем **New pull request.**
6. Перед нами откроется страница создания пулл-реквеста.
Здесь мы можем просмотреть внесенные изменения и выбрать две ветки: *одну в исходном репозитории*, на нее будут залиты наши изменения, *вторую – в нашем репозитории*, с нее будут скачаны изменения. Как только мы выбрали ветки и убедились, что не внесли никаких лишних изменений, нажимаем кнопку **Create pull request.**
7. Теперь мы попадаем на страницу описания наших изменений.
Здесь необходимо описать, что за изменения вы внесли и почему они были необходимы. *Оно должно отражать суть и необходимость внесенных изменений*. Как только мы закончили с описанием, можно нажимать кнопку **Create pull request.**
8. Теперь мы попадаем на страницу уже созданного пулл-реквеста в изначальном репозитоии. После того, как владелец репозитория просмотрит наши изменения и убедится, что они не имеют вредоносный характер, он сможет принять наш пулл-реквест. Тогда все изменения, добавленные в этот пулл-реквест нами, будут залиты в исходный репозиторий.

Таким образом, вы можете вносить свой вклад в абсолютно любые приложения с открытым программным кодом. Даже репозиторий самого Git хранится на GitHub, и вы в любой момент можете сделать форк и придумать новую команду (правда не факт, что ответственный примет ваш пулл-реквест). *Вы можете внести свой вклад в разработку **ядра Linux**, в популярный редактор Visual Studio Code, **в ядро криптовалюты Bitcoin**, в языки программирования **Python, Go, Ruby** – все эти проекты имеют открытые репозитории на GitHub.*

## Основные ветки

В нашей модели существуют две главные ветки:

* `main – ветка, в которой содержится только код, готовый к релизу.`
* `develop – ветка, в которой содержатся изменения, готовые ко включению в последующий релиз.`

Эти ветви называются главными, поскольку существуют в центральном репозитории и всех его копиях все время. Логика работы с ними не предполагает их удаления после выпуска очередного релиза, в отличие от, например, вспомогательных ветвей группы **release**.

Как только в ветке **develop** появляется достаточно изменений для создания нового релиза, она вливается в ветку **main** (напрямую или посредством создания специальной ветки *release-* *, о которой мы поговорим позже). После чего соответствующий коммит слияния в ветке **main** помечается тегом с указанием версии релиза *(напомним, что тег – это статический указатель, нужный для удобства переключения между коммитами).*

Таким образом, коммит в ветке **origin/main** означает выпуск нового релиза. Кстати, если строго придерживаться этого правила, можно организовать непрерывную интеграцию при помощи как встроенных средств *GitHub*, так и сторонних инструментов, специализирующихся на **CI/CDI.**

### Вспомогательные ветки

Чтобы поддерживать независимость разработки отдельных частей проекта, наша модель включает в себя несколько групп вспомогательных ветвей. Главное отличие таких ветвей от главных в том, что *срок жизни этих ветвей ограничен*. После завершения выполнения определенной работы, вспомогательная ветвь вливается в одну из главных, после чего удаляется.

Наша модель предполагает существование следующих групп вспомогательных ветвей:

* Ветви для разработки новых функций. Они же **feature branches.**
* Ветви релизов, то есть **release branches**.
* Ветви срочных исправлений – **hotfix branches**.

Чуть ниже мы разберем предназначение каждой группы. Кроме того, мы договоримся о правилах создания, именования и слияния ветвей из каждой группы. Конечно, *Git* не ограничивает ни в именах ветвей, ни в чем либо другом, – эти условности мы придумываем сами. Тем не менее, такие правила необходимы для облегчения взаимодействия нескольких разработчиков внутри одного большого проекта.

### **Feature**-ветки

* `Могут порождаться от: develop`
* `Могут вливаться в: develop`
* `Правило именования: любое имя, кроме main, develop, release-*, hotfix-*.`

Ветки функциональности используются для разработки новых функций, для которых неизвестно: будут ли они добавлены в ближайший релиз или же в какой-то более поздний. Основной смысл такой ветки в том, что живет она ровно столько, сколько продолжается разработка функции, для которой была создана эта ветка. В это время в ветке **main** могут выходить релизы, не затрагивающие разрабатываемую функцию. По завершении создания функции, такая ветка либо вливается в ветку **develop**, либо удаляется, если эксперимент с новой функцией не удался.

`Feature` - *ветки существуют в основном только в репозиториях разработчиков, но могут на некоторое время появиться и в центральном репозитории.*

**Создать feature-ветку можно следующим образом:**

* `$ git checkout develop`
* `$ git checkout -b new-feature`

**После завершения работы над функцией, вы можете выполнить слияние и Push:**

* `$ git checkout develop`
* `$ git merge --no-ff new-feature`
* `$ git branch -d new-feature`
* `$ git push origin develop`

Заметьте, мы специально выполнили **merge** в режиме `non-fast-forward`. Дело в том, что хоть **fast-forward** и удобнее в некоторых случаях, в данном все же лучше использовать **явное слияние**. *Явное слияние позволяет сохранить информацию о том, что ветка new-feature существовала, и объединяет все ее коммиты в один merge-коммит*.
Впоследствии это позволит разобраться, какие коммиты отвечают за **добавление одних и тех же функций**. Кроме того, сливая ветку явным образом, мы оставляем себе обходной путь: *отменить такое слияние намного проще, чем отменять слияние **fast-forward***.

### **Release**-ветки

* `Могут порождаться от: develop`
* `Могут вливаться в: develop, main`
* `Правило именования: release-*`

Ветки релизов необходимы для подготовки к выпуску новых релизов вашего продукта. Их главное назначение – внести финальные штрихи перед выпуском новой версии. В этих ветках можно вносить небольшие изменения и подготавливать файлы с метаданными о версии вашего продукта. **Release-ветку** следует создавать в тот момент, когда ваш проект готов или почти готов к выпуску очередной версии. По крайней мере не раньше, чем вся функциональность, предназначенная к выходу в этом релизе, будет влита в ветку **develop**.

Решение о номере версии релиза принимается только после создания release-ветки и опирается на принятые в компании правила нумерации версий. До тех пор неясно, будет ли новый релиз иметь версию **4.1.5, 4.2 или 5.0**. Создать **release-ветку** можно следующим образом.

* `$ git checkout develop`
* `$ git checkout -b release-4.2`

Заметьте, мы приняли решение, что новая версия будет иметь номер **4.2**, а потому создали ветку с именем **release-4.2**. Работая в этой ветке, мы можем исправить незначительные ошибки и внести метаинформацию о версии проекта в соответствующие файлы. Обратите внимание, что на этой ветви запрещено вносить какие-то крупные изменения или исправлять серьезные ошибки, ее предназначение не в этом.

Как только все файлы вашего проекта будут готовы к выпуску релиза, данную ветвь можно слить в основную ветку **main**, что и будет соответствовать выпуску релиза. После чего нужно пометить релиз соответствующим тегом, чтобы впоследствии к нему было проще обращаться. Важно не забыть слить изменения с **release-ветки** в ветку **develop**, чтобы вернуть наши незначительные изменения в процесс разработки следующего релиза.

* `$ git checkout main`
* `$ git merge --no-ff release-4.2`
* `$ git tag -a v4.2`
* `$ git checkout develop`
* `$ git merge --no-ff release-1.2`
* `$ git branch -d release-1.2`

### **Hotfix**-ветки

* `Могут порождаться от: main`
* `Могут вливаться в: develop, main`
* `Правило именования: hotfix-*`

Ветки срочных исправлений или **hotfix-ветки**, нужны для внесения срочных исправлений в уже вышедший релиз. Такую ветку необходимо создать в ситуации, когда в недавно вышедшем релизе был обнаружен серьезный баг. Предназначение этой ветки – исправить ошибку в последнем вышедшем релизе, а затем выпустить новый релиз, слив ветку **hotfix в main** и **develop**. Смысл создания отдельной ветки в том, что работа большей части команды может продолжаться над выходом нового стабильного релиза на ветке **develop**, пока **bugfix-команда** работает над исправлением ошибки в последнем релизе в ветке **hotfix**.

**Чтобы создать hotfix-ветку, выполните**:

* `$ git checkout main`
* `$ git checkout -b hotfix-4.2.1`

Последний релиз имеет номер **4.2**, поэтому мы приняли решение, что релиз с исправлением бага в релизе **4.2** будет иметь версию **4.2.1**.

После внесения всех необходимых исправлений, нужно слить **hotfix-ветку** в ветку **main**, чтобы выпустить новый релиз, и в ветку **develop**, чтобы наши изменения сохранились в следующем релизе. Сделаем это.

* `$ git checkout main`
* `$ git merge --no-ff hotfix-4.2.1`
* `$ git tag -a v4.2.1`
* `$ git checkout develop`
* `$ git merge --no-ff hotfix-4.2.1`
* `$ git branch -d hotfix-4.2.1`

$Подытожим$

М*одель, показанная нами выше, не является абсолютно новой. Тем не менее, в проект, разработка которого ведется в соответствии с данной моделью ветвления, очень легко вникнуть. У каждой ветки здесь есть свое строго регламентированное назначение, благодаря чему и достигается интуитивное понимание процесса разработки.*
